/**
 ******************************************************************************
  * @file    user_diskio_spi.c
  * @brief   This file contains the implementation of the user_diskio_spi FatFs
  *          driver.
  ******************************************************************************
  * Portions copyright (C) 2014, ChaN, all rights reserved.
  * Portions copyright (C) 2017, kiwih, all rights reserved.
  *
  * This software is a free software and there is NO WARRANTY.
  * No restriction on use. You can use, modify and redistribute it for
  * personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
  * Redistributions of source code must retain the above copyright notice.
  *
  ******************************************************************************
  */

//This code was ported by kiwih from a copywrited (C) library written by ChaN
//available at http://elm-chan.org/fsw/ff/ffsample.zip
//(text at http://elm-chan.org/fsw/ff/00index_e.html)

//This file provides the FatFs driver functions and SPI code required to manage
//an SPI-connected MMC or compatible SD card with FAT

//It is designed to be wrapped by a cubemx generated user_diskio.c file.

#include "device_flash.h"
#include "diskio.h"

static volatile
DSTATUS Stat = STA_NOINIT;    /* Physical drive status */

#define BLOCK_SIZE 4096
#define SECTOR_SIZE 512
// W25Qxx_FlashSize / SECTOR_SIZE
#define SECTOR_COUNT 0x10000
#define MAX_READ_SIZE BLOCK_SIZE
#define MAX_WRITE_SIZE BLOCK_SIZE


/*--------------------------------------------------------------------------
   Public FatFs Functions (wrapped in user_diskio.c)
---------------------------------------------------------------------------*/

//The following functions are defined as inline because they aren't the functions that
//are passed to FatFs - they are wrapped by autogenerated (non-inline) cubemx template
//code.
//If you do not wish to use cubemx, remove the "inline" from these functions here
//and in the associated .h


/*-----------------------------------------------------------------------*/
/* Initialize disk drive                                                 */
/*-----------------------------------------------------------------------*/

inline DSTATUS disk_initialize(
        BYTE drv        /* Physical drive number (0) */
) {
    if (drv) return STA_NOINIT;        /* Supports only drive 0 */

    Stat = STA_NOINIT;

    if (flash_read_id() == W25Qxx_FLASH_ID) {
        Stat &= ~STA_NOINIT;
    }

    return Stat;    /* Return disk status */
}



/*-----------------------------------------------------------------------*/
/* Get disk status                                                       */
/*-----------------------------------------------------------------------*/

inline DSTATUS disk_status(
        BYTE drv        /* Physical drive number (0) */
) {
    if (drv) return STA_NOINIT;        /* Supports only drive 0 */

    return Stat;    /* Return disk status */
}



/*-----------------------------------------------------------------------*/
/* Read sector(s)                                                        */
/*-----------------------------------------------------------------------*/

inline DRESULT disk_read(
        BYTE drv,        /* Physical drive number (0) */
        BYTE *buff,        /* Pointer to the data buffer to store read data */
        DWORD sector,    /* Start sector number (LBA) */
        UINT count        /* Number of sectors to read (1..128) */
) {
    if (drv || !count) return RES_PARERR;        /* Check parameter */
    if (Stat & STA_NOINIT) return RES_NOTRDY;    /* Check if drive is ready */

    uint32_t bufferSize = (SECTOR_SIZE * count);
    uint32_t address = (sector * SECTOR_SIZE);
    uint32_t dataRead = 0;
    while (dataRead < bufferSize) {
        uint32_t incr = bufferSize < MAX_READ_SIZE ? bufferSize : MAX_READ_SIZE;
        if (flash_read_buffer(buff + dataRead, address, incr) != QSPI_W25Qxx_OK) {
            return RES_ERROR;
        }
        dataRead += incr;
        address += incr;
    }

    return RES_OK;    /* Return result */
}



/*-----------------------------------------------------------------------*/
/* Write sector(s)                                                       */
/*-----------------------------------------------------------------------*/

inline DRESULT disk_write (
    BYTE drv,			/* Physical drive number (0) */
    const BYTE *buff,	/* Ponter to the data to write */
    DWORD sector,		/* Start sector number (LBA) */
    UINT count			/* Number of sectors to write (1..128) */
)
{
    if (drv || !count) return RES_PARERR;		/* Check parameter */
    if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check drive status */
    if (Stat & STA_PROTECT) return RES_WRPRT;	/* Check write protect */

    uint32_t bufferSize = (SECTOR_SIZE * count);
    uint32_t address = (sector * SECTOR_SIZE);
    uint32_t dataWritten = 0;
    while (dataWritten < bufferSize) {
        uint32_t incr = bufferSize < MAX_WRITE_SIZE ? bufferSize : MAX_WRITE_SIZE;
        if (flash_sector_erase(address) != QSPI_W25Qxx_OK) {
            return RES_ERROR;
        }
        if (flash_write_buffer((uint8_t *) (buff + dataWritten), address, incr) != QSPI_W25Qxx_OK) {
            return RES_ERROR;
        }
        dataWritten += incr;
        address += incr;
    }

    return RES_OK;	/* Return result */
}


/*-----------------------------------------------------------------------*/
/* Miscellaneous drive controls other than data read/write               */
/*-----------------------------------------------------------------------*/

inline DRESULT disk_ioctl (
    BYTE drv,		/* Physical drive number (0) */
    BYTE cmd,		/* Control command code */
    void *buff		/* Pointer to the conrtol data */
)
{
    DRESULT res;

    if (drv) return RES_PARERR;					/* Check parameter */
    if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */

    switch (cmd) {
        case CTRL_SYNC :		/* Wait for end of internal write process of the drive */
            res = RES_OK;
            break;

        case GET_SECTOR_SIZE:   /* Get r/w sector size (DWORD) */
            *(DWORD*)buff = SECTOR_SIZE;
            res = RES_OK;
            break;

        case GET_SECTOR_COUNT:	/* Get drive capacity in unit of sector (DWORD) */
            *(DWORD*)buff = SECTOR_COUNT;
            res = RES_OK;
            break;

        case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
            *(DWORD*)buff = BLOCK_SIZE;
            res = RES_OK;
            break;

        default:
            res = RES_PARERR;
    }

    return res;
}
